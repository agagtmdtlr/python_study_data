
# 파일 이름 : numpy1.py
import numpy as np

# Numpy 배열은 동일한 자료형을 가지는 값들이 격자판 형태로 있는 것입니다.
# 각각의 값들은 튜플(이때 튜플은 양의 정수만을 요소값으로 갖습니다.) 형태로 색인 됩니다.
# rank : 배열의 차원 수
# shape는 각 차원의 크기를 알려주는 정수들이 모인 튜플이다.
#
# 파이썬의 리스트를 중첩해 Numpy 배열을 초기화 할 수 있고, 대괄호를 통해 각 요소에 접근할 수 있습니다:

# rank : 배열이 몇 차원인지를 의미합니다;

# 2차원 배열(rank : 2)인 배열 생성
b = np.array([[1, 2, 3], [4, 5, 6]])
print ( '(행, 열) =', b.shape )  # 출력 "(2, 3)"
print (b[0, 0], b[0, 1], b[1, 0])  # 출력 "1 2 4"
print('# 2차원 배열 출력')
print ( b )


Numpy는 배열 연산에 유용하게 쓰이는 많은 함수를 제공한다. 가장 유용한 건 ‘sum’이다:

import numpy as np

arr = np.array([[1,2],[3,4]])

print np.sum(arr)  # 모든 요소를 합한 값을 연산; 출력 "10"
print np.sum(arr, axis=0)  # 각 열에 대한 합을 연산; 출력 "[4 6]"
print np.sum(arr, axis=1)  # 각 행에 대한 합을 연산; 출력 "[3 7]"
Numpy가 제공하는 모든 수학함수의 목록은 문서를 참조하세요.

배열연산을 하지 않더라도, 종종 배열의 모양을 바꾸거나 데이터를 처리해야 할 때가 있습니다. 가장 간단한 예는 행렬의 주 대각선을 기준으로 대칭되는 요소끼리 뒤바꾸는 것이다; 이를 전치라고 하며 행렬을 전치하기 위해선, 간단하게 배열 객체의 ‘T’ 속성을 사용하면 됩니다:

import numpy as np

arr = np.array([[1,2], [3,4]])
print arr    # 출력 "[[1 2]
           #          [3 4]]"
print arr.T  # 출력 "[[1 3]
           #          [2 4]]"

# rank 1인 배열을 전치할 경우 아무 일도 일어나지 않습니다:
v = np.array([1,2,3])
print v    # 출력 "[1 2 3]"
print v.T  # 출력 "[1 2 3]"
Numpy는 배열을 다루는 다양한 함수들을 제공한다; 이러한 함수의 전체 목록은 문서를 참조하세요.


브로드캐스팅

브로트캐스팅은 Numpy에서 shape가 다른 배열 간에도 산술 연산이 가능하게 하는 메커니즘이다. 종종 작은 배열과 큰 배열이 있을 때, 큰 배열을 대상으로 작은 배열을 여러 번 연산하고자 할 때가 있습니다. 예를 들어, 행렬의 각 행에 상수 벡터를 더하는 걸 생각해보세요. 이는 다음과 같은 방식으로 처리될 수 있습니다:

import numpy as np

# 행렬 x의 각 행에 벡터 v를 더한 뒤,
# 그 결과를 행렬 y에 저장하고자 한다
arr = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = np.empty_like(arr)   # x와 동일한 shape를 가지며 비어있는 행렬 생성

# 명시적 반복문을 통해 행렬 x의 각 행에 벡터 v를 더하는 방법
for i in range(4):
    y[i, :] = arr[i, :] + v

# 이제 y는 다음과 같습니다
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]
print y
위의 방식대로 하면 됩니다; 그러나 ‘x’가 매우 큰 행렬이라면, 파이썬의 명시적 반복문을 이용한 위 코드는 매우 느려질 수 있습니다. 벡터 ‘v’를 행렬 ‘x’의 각 행에 더하는 것은 ‘v’를 여러 개 복사해 수직으로 쌓은 행렬 ‘vv’를 만들고 이 ‘vv’를 ‘x’에 더하는것과 동일한다. 이 과정을 아래의 코드로 구현할 수 있습니다:

import numpy as np

# 벡터 v를 행렬 x의 각 행에 더한 뒤,
# 그 결과를 행렬 y에 저장하고자 한다
arr = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
vv = np.tile(v, (4, 1))  # v의 복사본 4개를 위로 차곡차곡 쌓은 것이 vv
print vv                 # 출력 "[[1 0 1]
                         #       [1 0 1]
                         #       [1 0 1]
                         #       [1 0 1]]"
y = arr + vv  # x와 vv의 요소별 합
print y  # 출력 "[[ 2  2  4
         #       [ 5  5  7]
         #       [ 8  8 10]
         #       [11 11 13]]"
Numpy 브로드캐스팅을 이용한다면 이렇게 v의 복사본을 여러 개 만들지 않아도 동일한 연산을 할 수 있습니다. 아래는 브로드캐스팅을 이용한 예시 코드이다:

import numpy as np

# 벡터 v를 행렬 x의 각 행에 더한 뒤,
# 그 결과를 행렬 y에 저장하고자 한다
arr = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = arr + v  # 브로드캐스팅을 이용하여 v를 x의 각 행에 더하기
print y  # 출력 "[[ 2  2  4]
         #       [ 5  5  7]
         #       [ 8  8 10]
         #       [11 11 13]]"
x의 shape가 (4, 3)이고 v의 shape가 (3,)라도 브로드캐스팅으로 인해 y = arr + v는 문제없이 수행됩니다; 이때 ‘v’는 ‘v’의 복사본이 차곡차곡 쌓인 shape (4, 3)처럼 간주되어 ‘x’와 동일한 shape가 되며 이들 간의 요소별 덧셈연산이 y에 저장됩니다.

두 배열의 브로드캐스팅은 아래의 규칙을 따릅니다:

두 배열이 동일한 rank를 가지고 있지 않다면, 낮은 rank의 1차원 배열이 높은 rank 배열의 shape로 간주한다.
특정 차원에서 두 배열이 동일한 크기를 갖거나, 두 배열 중 하나의 크기가 1이라면 그 두 배열은 특정 차원에서 compatible하다고 여겨집니다.
두 행렬이 모든 차원에서 compatible하다면, 브로드캐스팅이 가능한다.
브로드캐스팅이 이뤄지면, 각 배열 shape의 요소별 최소공배수로 이루어진 shape가 두 배열의 shape로 간주한다.
차원에 상관없이 크기가 1인 배열과 1보다 큰 배열이 있을 때, 크기가 1인 배열은 자신의 차원 수만큼 복사되어 쌓인 것처럼 간주한다.
설명이 이해하기 부족하다면 scipy문서나 scipy위키를 참조하세요.

브로드캐스팅을 지원하는 함수를 universal functions라고 한다. universal functions 목록은 문서를 참조하세요.

브로드캐스팅을 응용한 예시들이다:

import numpy as np

# 벡터의 외적을 계산
v = np.array([1,2,3])  # v의 shape는 (3,)
w = np.array([4,5])    # w의 shape는 (2,)
# 외적을 계산하기 위해, 먼저 v를 shape가 (3,1)인 행벡터로 바꿔야 한다;
# 그다음 이것을 w에 맞춰 브로드캐스팅한뒤 결과물로 shape가 (3,2)인 행렬을 얻습니다,
# 이 행렬은 v와 w 외적의 결과이다:
# [[ 4  5]
#  [ 8 10]
#  [12 15]]
print np.reshape(v, (3, 1)) * w

# 벡터를 행렬의 각 행에 더하기
arr = np.array([[1,2,3], [4,5,6]])
# x는 shape가 (2, 3)이고 v는 shape가 (3,)이므로 이 둘을 브로드캐스팅하면 shape가 (2, 3)인
# 아래와 같은 행렬이 나옵니다:
# [[2 4 6]
#  [5 7 9]]
print arr + v

# 벡터를 행렬의 각 행에 더하기
# x는 shape가 (2, 3)이고 w는 shape가 (2,)이다.
# x의 전치행렬은 shape가 (3,2)이며 이는 w와 브로드캐스팅이 가능하고 결과로 shape가 (3,2)인 행렬이 생깁니다;
# 이 행렬을 전치하면 shape가 (2,3)인 행렬이 나오며
# 이는 행렬 x의 각 열에 벡터 w을 더한 결과와 동일한다.
# 아래의 행렬이다:
# [[ 5  6  7]
#  [ 9 10 11]]
print (arr.T + w).T
# 다른 방법은 w를 shape가 (2,1)인 열벡터로 변환하는 것이다;
# 그런 다음 이를 바로 x에 브로드캐스팅해 더하면
# 동일한 결과가 나옵니다.
print arr + np.reshape(w, (2, 1))

# 행렬의 스칼라배:
# arr 의 shape는 (2, 3)이다. Numpy는 스칼라를 shape가 ()인 배열로 취급한다;
# 그렇기에 스칼라 값은 (2,3) shape로 브로드캐스트 될 수 있고,
# 아래와 같은 결과를 만들어 냅니다:
# [[ 2  4  6]
#  [ 8 10 12]]
print arr * 2
브로드캐스팅은 보통 코드를 간결하고 빠르게 해줍니다, 그러니 가능한 많이 사용하세요.

Numpy Documentation

이 문서는 여러분이 numpy에 대해 알아야할 많은 중요한 사항들을 다루지만 완벽하진 않습니다. numpy에 관한 더 많은 사항은 numpy 레퍼런스를 참조하세요.


SciPy

Numpy는 고성능의 다차원 배열 객체와 이를 다룰 도구를 제공한다. numpy를 바탕으로 만들어진 SciPy는, numpy 배열을 다루는 많은 함수를 제공하며 다양한 과학, 공학분야에서 유용하게 사용됩니다.

SciPy에 익숙해지는 최고의 방법은 SciPy 공식 문서를 보는 것이다. 이 문서에서는 scipy중 cs231n 수업에서 유용하게 쓰일 일부분만을 소개할것이다.


이미지 작업

SciPy는 이미지를 다룰 기본적인 함수들을 제공한다. 예를들자면, 디스크에 저장된 이미지를 numpy 배열로 읽어 들이는 함수가 있으며, numpy 배열을 디스크에 이미지로 저장하는 함수도 있고, 이미지의 크기를 바꾸는 함수도 있습니다. 이 함수들의 간단한 사용 예시이다:

from scipy.misc import imread, imsave, imresize

# JPEG 이미지를 numpy 배열로 읽어들이기
img = imread('assets/cat.jpg')
print img.dtype, img.shape  # 출력 "uint8 (400, 248, 3)"

# 각각의 색깔 채널을 다른 상수값으로 스칼라배함으로써
# 이미지의 색을 변화시킬 수 있습니다.
# 이미지의 shape는 (400, 248, 3)이다;
# 여기에 shape가 (3,)인 배열 [1, 0.95, 0.9]를 곱한다;
# numpy 브로드캐스팅에 의해 이 배열이 곱해지며 붉은색 채널은 변하지 않으며,
# 초록색, 파란색 채널에는 각각 0.95, 0.9가 곱해집니다
img_tinted = img * [1, 0.95, 0.9]

# 색변경 이미지를 300x300픽셀로 크기 조절.
img_tinted = imresize(img_tinted, (300, 300))

# 색변경 이미지를 디스크에 기록하기
imsave('assets/cat_tinted.jpg', img_tinted)
  
Left: 원본 이미지. Right: 색변경 & 크기변경 이미지.